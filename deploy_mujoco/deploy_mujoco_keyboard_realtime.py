import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent.absolute()))

from common.path_config import PROJECT_ROOT

import time
import mujoco.viewer
import mujoco
import numpy as np
import yaml
import os
import threading
import queue
import select  # Linux/Mac
import tty
import termios
from common.ctrlcomp import *
from FSM.FSM import *
from common.utils import get_gravity_orientation, FSMCommand

class RealtimeKeyboardController:
    def __init__(self):
        self.command_queue = queue.Queue()
        self.running = True
        self.current_cmd = "Êó†ÂëΩ‰ª§"
        self.vel_cmd = np.array([0.0, 0.0, 0.0], dtype=np.float32)
        self.key_states = {}
        
    def start_keyboard_listener(self):
        """ÂêØÂä®ÂÆûÊó∂ÈîÆÁõòÁõëÂê¨Á∫øÁ®ã"""
        def keyboard_listener():
            print("ÂÆûÊó∂ÈîÆÁõòÊéßÂà∂ËØ¥Êòé:")
            print("Êï∞Â≠óÈîÆ 1-7: ÂàáÊç¢‰∏çÂêåÊ®°Âºè")
            print("  1: ÈòªÂ∞º‰øùÊä§Ê®°Âºè (PASSIVE)")
            print("  2: ‰ΩçÊéßÊ®°Âºè (POS_RESET)")
            print("  3: Ë°åËµ∞Ê®°Âºè (LOCO)")
            print("  4: ËàûËπàÊ®°Âºè (SKILL_1)")
            print("  5: Ê≠¶ÊúØÊ®°Âºè (SKILL_2)")
            print("  6: Ë∏¢ËÖøÊ®°Âºè (SKILL_3)")
            print("  7: ‰∏äËÇ¢ËàûËπàÊ®°Âºè (SKILL_4)")
            print("  q: ÈÄÄÂá∫Á®ãÂ∫è")
            print("  w/s/a/d: Âä†ÈÄüÊéßÂà∂ (ÂâçËøõ/ÂêéÈÄÄ/Â∑¶Áßª/Âè≥Áßª) +0.2")
            print("  j/l: ËΩ¨Ë∫´Âä†ÈÄü (Â∑¶ËΩ¨/Âè≥ËΩ¨) +0.2")
            print("  z: ÂÅúÊ≠¢Ëµ∞Ë∑Ø")
            print("Êåâ‰ªªÊÑèÈîÆÂºÄÂßã...")
            
            # ËÆæÁΩÆÈùûÈòªÂ°ûËæìÂÖ•
            old_settings = termios.tcgetattr(sys.stdin)
            try:
                tty.setcbreak(sys.stdin.fileno())
                
                while self.running:
                    try:
                        # Ê£ÄÊµãÊåâÈîÆËæìÂÖ•
                        if select.select([sys.stdin], [], [], 0.01)[0]:
                            key = sys.stdin.read(1).lower()
                            self.process_key(key)
                        
                    except KeyboardInterrupt:
                        self.running = False
                        break
                    except Exception as e:
                        print(f"ÈîÆÁõòÁõëÂê¨ÈîôËØØ: {e}")
                        break
            finally:
                termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
        
        # ÂêØÂä®ÈîÆÁõòÁõëÂê¨Á∫øÁ®ã
        keyboard_thread = threading.Thread(target=keyboard_listener, daemon=True)
        keyboard_thread.start()
    
    def process_key(self, key):
        """Â§ÑÁêÜÊåâÈîÆËæìÂÖ•"""
        if key == 'q':
            self.running = False
        elif key == '1':
            self.command_queue.put(FSMCommand.PASSIVE)
            self.current_cmd = "PASSIVE (ÈòªÂ∞º‰øùÊä§Ê®°Âºè)"
        elif key == '2':
            self.command_queue.put(FSMCommand.POS_RESET)
            self.current_cmd = "POS_RESET (‰ΩçÊéßÊ®°Âºè)"
        elif key == '3':
            self.command_queue.put(FSMCommand.LOCO)
            self.current_cmd = "LOCO (Ë°åËµ∞Ê®°Âºè)"
        elif key == '4':
            self.command_queue.put(FSMCommand.SKILL_1)
            self.current_cmd = "SKILL_1 (ËàûËπàÊ®°Âºè)"
        elif key == '5':
            self.command_queue.put(FSMCommand.SKILL_2)
            self.current_cmd = "SKILL_2 (Ê≠¶ÊúØÊ®°Âºè)"
        elif key == '6':
            self.command_queue.put(FSMCommand.SKILL_3)
            self.current_cmd = "SKILL_3 (Ë∏¢ËÖøÊ®°Âºè)"
        elif key == '7':
            self.command_queue.put(FSMCommand.SKILL_4)
            self.current_cmd = "SKILL_4 (‰∏äËÇ¢ËàûËπàÊ®°Âºè)"
        elif key == 'w':
            self.vel_cmd[0] += 0.2  # ÂâçËøõÂä†ÈÄü
            self.vel_cmd[0] = min(self.vel_cmd[0], 2.0)  # ÈôêÂà∂ÊúÄÂ§ßÈÄüÂ∫¶
            self.current_cmd = f"ÂâçËøõÂä†ÈÄü: {self.vel_cmd[0]:.1f}"
        elif key == 's':
            self.vel_cmd[0] -= 0.2  # ÂêéÈÄÄÂä†ÈÄü
            self.vel_cmd[0] = max(self.vel_cmd[0], -2.0)  # ÈôêÂà∂ÊúÄÂ§ßÈÄüÂ∫¶
            self.current_cmd = f"ÂêéÈÄÄÂä†ÈÄü: {self.vel_cmd[0]:.1f}"
        elif key == 'a':
            self.vel_cmd[1] += 0.2  # Â∑¶ÁßªÂä†ÈÄü
            self.vel_cmd[1] = min(self.vel_cmd[1], 2.0)  # ÈôêÂà∂ÊúÄÂ§ßÈÄüÂ∫¶
            self.current_cmd = f"Â∑¶ÁßªÂä†ÈÄü: {self.vel_cmd[1]:.1f}"
        elif key == 'd':
            self.vel_cmd[1] -= 0.2  # Âè≥ÁßªÂä†ÈÄü
            self.vel_cmd[1] = max(self.vel_cmd[1], -2.0)  # ÈôêÂà∂ÊúÄÂ§ßÈÄüÂ∫¶
            self.current_cmd = f"Âè≥ÁßªÂä†ÈÄü: {self.vel_cmd[1]:.1f}"
        elif key == 'j':
            self.vel_cmd[2] += 0.2  # Â∑¶ËΩ¨Âä†ÈÄü
            self.vel_cmd[2] = min(self.vel_cmd[2], 2.0)  # ÈôêÂà∂ÊúÄÂ§ßËßíÈÄüÂ∫¶
            self.current_cmd = f"Â∑¶ËΩ¨Âä†ÈÄü: {self.vel_cmd[2]:.1f}"
        elif key == 'l':
            self.vel_cmd[2] -= 0.2  # Âè≥ËΩ¨Âä†ÈÄü
            self.vel_cmd[2] = max(self.vel_cmd[2], -2.0)  # ÈôêÂà∂ÊúÄÂ§ßËßíÈÄüÂ∫¶
            self.current_cmd = f"Âè≥ËΩ¨Âä†ÈÄü: {self.vel_cmd[2]:.1f}"
        elif key == ' ':  # Á©∫Ê†ºÈîÆÈáçÁΩÆÈÄüÂ∫¶
            self.vel_cmd = np.array([0.0, 0.0, 0.0], dtype=np.float32)
            self.current_cmd = "ÊëáÊùÜÈáçÁΩÆ"
        elif key == 'z':
            self.vel_cmd = np.array([0.0, 0.0, 0.0], dtype=np.float32)
            self.current_cmd = "ÂÅúÊ≠¢Ëµ∞Ë∑Ø"
    
    def get_command(self):
        """Ëé∑ÂèñÂëΩ‰ª§ÈòüÂàó‰∏≠ÁöÑÂëΩ‰ª§"""
        try:
            return self.command_queue.get_nowait()
        except queue.Empty:
            return FSMCommand.INVALID
    
    def get_vel_cmd(self):
        """Ëé∑ÂèñÈÄüÂ∫¶ÂëΩ‰ª§"""
        return self.vel_cmd.copy()

def print_status_table(keyboard_controller, FSM_controller, qpos=None):
    """ÊâìÂç∞Áä∂ÊÄÅË°®Ê†º"""
    os.system('clear' if os.name == 'posix' else 'cls')
    
    print("=" * 80)
    print("‚å®Ô∏è  ÂÆûÊó∂ÈîÆÁõòÊéßÂà∂Êú∫Âô®‰∫∫‰ªøÁúü")
    print("=" * 80)
    print()
    
    print("üéØ ÂΩìÂâçÁä∂ÊÄÅ:")
    print("-" * 50)
    print(f"ÊúÄÊñ∞ÂëΩ‰ª§: {keyboard_controller.current_cmd}")
    print(f"ÂΩìÂâçÊ®°Âºè: {FSM_controller.cur_policy.name_str}")
    print(f"ÈÄüÂ∫¶ÂëΩ‰ª§: [{keyboard_controller.vel_cmd[0]:.2f}, {keyboard_controller.vel_cmd[1]:.2f}, {keyboard_controller.vel_cmd[2]:.2f}]")
    
    # ÊòæÁ§∫Êú∫Âô®‰∫∫ÂÖ≥ËäÇ‰ΩçÁΩÆÁä∂ÊÄÅ
    if qpos is not None:
        print(f"Êú∫Âô®‰∫∫‰ΩçÁΩÆ: [{qpos[0]:.3f}, {qpos[1]:.3f}, {qpos[2]:.3f}]")
        if len(qpos) > 7:
            quat = qpos[3:7]  # Ê†πËäÇÁÇπÂßøÊÄÅÂõõÂÖÉÊï∞
            print(f"Ê†πËäÇÁÇπÂßøÊÄÅÂõõÂÖÉÊï∞: [{quat[0]:.3f}, {quat[1]:.3f}, {quat[2]:.3f}, {quat[3]:.3f}]")
            joint_pos = qpos[7:]  # ÂÖ≥ËäÇ‰ΩçÁΩÆÔºàË∑≥ËøáÂâç7‰∏™‰ΩçÁΩÆÂíåÂßøÊÄÅÔºâ
            print(f"ÂÖ≥ËäÇ‰ΩçÁΩÆ: [{', '.join([f'{pos:.3f}' for pos in joint_pos])}]")
    
    print()
    print("üí° Êìç‰ΩúËØ¥Êòé:")
    print("-" * 50)
    print("1 ‚Üí ÈòªÂ∞º‰øùÊä§Ê®°Âºè (PASSIVE)")
    print("2 ‚Üí ‰ΩçÊéßÊ®°Âºè (POS_RESET)")
    print("3 ‚Üí Ë°åËµ∞Ê®°Âºè (LOCO)")
    print("4 ‚Üí ËàûËπàÊ®°Âºè (SKILL_1)")
    print("5 ‚Üí Ê≠¶ÊúØÊ®°Âºè (SKILL_2)")
    print("6 ‚Üí Ë∏¢ËÖøÊ®°Âºè (SKILL_3)")
    print("7 ‚Üí ‰∏äËÇ¢ËàûËπàÊ®°Âºè (SKILL_4)")
    print("w/s/a/d ‚Üí Âä†ÈÄüÊéßÂà∂ (ÂâçËøõ/ÂêéÈÄÄ/Â∑¶Áßª/Âè≥Áßª) +0.2")
    print("j/l ‚Üí ËΩ¨Ë∫´Âä†ÈÄü (Â∑¶ËΩ¨/Âè≥ËΩ¨) +0.2")
    print("z ‚Üí ÂÅúÊ≠¢Ëµ∞Ë∑Ø")
    print("Á©∫Ê†ºÈîÆ ‚Üí ÈáçÁΩÆÊëáÊùÜ")
    print("q ‚Üí ÈÄÄÂá∫Á®ãÂ∫è")
    
    print()
    print("=" * 80)
    print("Êåâ Ctrl+C ÈÄÄÂá∫Á®ãÂ∫è")
    print("=" * 80)

def pd_control(target_q, q, kp, target_dq, dq, kd):
    """Calculates torques from position commands"""
    return (target_q - q) * kp + (target_dq - dq) * kd

if __name__ == "__main__":
    current_dir = os.path.dirname(os.path.abspath(__file__))
    mujoco_yaml_path = os.path.join(current_dir, "config", "mujoco.yaml")
    with open(mujoco_yaml_path, "r") as f:
        config = yaml.load(f, Loader=yaml.FullLoader)
        xml_path = os.path.join(PROJECT_ROOT, config["xml_path"])
        simulation_dt = config["simulation_dt"]
        control_decimation = config["control_decimation"]
        
    m = mujoco.MjModel.from_xml_path(xml_path)
    d = mujoco.MjData(m)
    m.opt.timestep = simulation_dt
    mj_per_step_duration = simulation_dt * control_decimation
    num_joints = m.nu
    policy_output_action = np.zeros(num_joints, dtype=np.float32)
    kps = np.zeros(num_joints, dtype=np.float32)
    kds = np.zeros(num_joints, dtype=np.float32)
    sim_counter = 0
    
    state_cmd = StateAndCmd(num_joints)
    policy_output = PolicyOutput(num_joints)
    FSM_controller = FSM(state_cmd, policy_output)
    
    keyboard_controller = RealtimeKeyboardController()
    keyboard_controller.start_keyboard_listener()
    
    # ÂàùÂßãÂåñÊòæÁ§∫
    print_status_table(keyboard_controller, FSM_controller, d.qpos)
    
    with mujoco.viewer.launch_passive(m, d) as viewer:
        sim_start_time = time.time()
        last_display_update = time.time()
        
        while viewer.is_running() and keyboard_controller.running:
            try:
                # Ëé∑ÂèñÈîÆÁõòÂëΩ‰ª§
                cmd = keyboard_controller.get_command()
                if cmd != FSMCommand.INVALID:
                    state_cmd.skill_cmd = cmd
                    print(f"Êî∂Âà∞ÂëΩ‰ª§: {cmd} -> {keyboard_controller.current_cmd}")
                
                # Ëé∑ÂèñÈÄüÂ∫¶ÂëΩ‰ª§
                state_cmd.vel_cmd = keyboard_controller.get_vel_cmd()
                
                step_start = time.time()
                
                tau = pd_control(policy_output_action, d.qpos[7:], kps, np.zeros_like(kps), d.qvel[6:], kds)
                d.ctrl[:] = tau
                mujoco.mj_step(m, d)
                sim_counter += 1
                if sim_counter % control_decimation == 0:
                    
                    qj = d.qpos[7:]
                    dqj = d.qvel[6:]
                    quat = d.qpos[3:7]
                    
                    omega = d.qvel[3:6] 
                    gravity_orientation = get_gravity_orientation(quat)
                    
                    state_cmd.q = qj.copy()
                    state_cmd.dq = dqj.copy()
                    state_cmd.gravity_ori = gravity_orientation.copy()
                    state_cmd.ang_vel = omega.copy()
                    
                    FSM_controller.run()
                    policy_output_action = policy_output.actions.copy()
                    kps = policy_output.kps.copy()
                    kds = policy_output.kds.copy()
                
                # ÊØè0.2ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°ÊòæÁ§∫
                if time.time() - last_display_update > 0.2:
                    print_status_table(keyboard_controller, FSM_controller, d.qpos)
                    last_display_update = time.time()
                    
            except ValueError as e:
                print(str(e))
            
            viewer.sync()
            time_until_next_step = m.opt.timestep - (time.time() - step_start)
            if time_until_next_step > 0:
                time.sleep(time_until_next_step)
        
        print("Á®ãÂ∫èÈÄÄÂá∫") 